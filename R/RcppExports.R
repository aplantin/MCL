# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' mclC
#'
#' Runs my multilevel compositional lasso
#'
#' @param Z OTU matrix (group level)
#' @param W OTU matrix (within-group level)
#' @param y Vector of outcomes
#' @param facZ Scaling factors for Z
#' @param facW Scaling factors for W
#' @param groups Vector of group membership
#' @param groupIdx List of feature indices in each group
#' @param mu Lagrange scaling parameter
#' @param lam1 Lambda for group-level lasso penalty
#' @param lam2 Lambda for within-group lasso penalty
#' @param thresh Parameter defining convergence
#' @param maxit Maximum number of iterations allowed
#' @export
mclC <- function(Z, W, y, facZ, facW, groups, groupIdx, mu, lam1, lam2, thresh, maxit) {
    .Call('_MCL_mclC', PACKAGE = 'MCL', Z, W, y, facZ, facW, groups, groupIdx, mu, lam1, lam2, thresh, maxit)
}

#' findMaxLams
#'
#' Finds maximum lambda value (smallest lambda such
#' that all coefficients are zero) for both lam1 and lam2
#'
#' @param Z OTU matrix (group level)
#' @param W OTU matrix (within-group level)
#' @param y Vector of outcomes
#' @param facZ Scaling factors for Z
#' @param facW Scaling factors for W
#' @param groups Vector indicating group membership for each feature
#' @param groupIdx List indicating feature indices in each group
#' @param mu Lagrange scaling parameter
#' @param maxit Maximum number of iterations allowed
#' @param thresh Parameter defining convergence
#' @export
findMaxLams <- function(Z, W, y, facZ, facW, groups, groupIdx, mu, maxit, thresh) {
    .Call('_MCL_findMaxLams', PACKAGE = 'MCL', Z, W, y, facZ, facW, groups, groupIdx, mu, maxit, thresh)
}

#' mclC
#'
#' Runs my multilevel compositional lasso
#'
#' @param Z OTU matrix (group level)
#' @param W OTU matrix (within-group level)
#' @param y Vector of outcomes
#' @param facZ Scaling factors for Z
#' @param facW Scaling factors for W
#' @param step Step-size
#' @param groups Vector of group membership
#' @param groupIdx List of feature indices in each group
#' @param mu Lagrange scaling parameter
#' @param lam1 Lambda for group-level lasso penalty
#' @param lam2 Lambda for within-group lasso penalty
#' @param thresh Parameter defining convergence
#' @param maxit Maximum number of iterations allowed
#' @return List of beta matrix, gamma matrix
#' @export
mclC_step <- function(Z, W, y, facZ, facW, step, groups, groupIdx, mu, lam1, lam2, thresh, maxit) {
    .Call('_MCL_mclC_step', PACKAGE = 'MCL', Z, W, y, facZ, facW, step, groups, groupIdx, mu, lam1, lam2, thresh, maxit)
}

#' findMaxLams
#'
#' Finds maximum lambda value (smallest lambda such
#' that all coefficients are zero) for both lam1 and lam2
#'
#' @param Z OTU matrix (group level)
#' @param W OTU matrix (within-group level)
#' @param y Vector of outcomes
#' @param facZ Scaling factors for Z
#' @param facW Scaling factors for W
#' @param step Step-size
#' @param groups Vector indicating group membership for each feature
#' @param groupIdx List indicating feature indices in each group
#' @param mu Lagrange scaling parameter
#' @param maxit Maximum number of iterations allowed
#' @param thresh Parameter defining convergence
#' @return vector with maxlam1, maxlam2
#' @export
findMaxLams_step <- function(Z, W, y, facZ, facW, step, groups, groupIdx, mu, maxit, thresh) {
    .Call('_MCL_findMaxLams_step', PACKAGE = 'MCL', Z, W, y, facZ, facW, step, groups, groupIdx, mu, maxit, thresh)
}

#' signC
#'
#' Finds the sign of a double
#'
#' @param x Number to find the sign of
#' @export
signC <- function(x) {
    .Call('_MCL_signC', PACKAGE = 'MCL', x)
}

#' absC
#'
#' Finds the absolute value of a double
#'
#' @param x Number to take abs value of
#' @export
absC <- function(x) {
    .Call('_MCL_absC', PACKAGE = 'MCL', x)
}

#' absC2
#'
#' Finds the absolute value of each element in a numeric vector
#'
#' @param x Vector to take abs value of
#' @export
absC2 <- function(x) {
    .Call('_MCL_absC2', PACKAGE = 'MCL', x)
}

#' softC
#'
#' Thresholds x by lambda
#'
#' @param x Number to soft threshold
#' @param lam Parameter by which to soft threshold
#' @export
softC <- function(x, lam) {
    .Call('_MCL_softC', PACKAGE = 'MCL', x, lam)
}

#' softC2
#'
#' Soft thresholds each element of a vector x by lambda
#'
#' @param x Vector whose elements should be soft thresholded
#' @param lam Parameter by which to soft threshold
#' @export
softC2 <- function(x, lam) {
    .Call('_MCL_softC2', PACKAGE = 'MCL', x, lam)
}

#' sqrtC
#'
#' Finds the square root of a double
#'
#' @param x Number to take sqrt of
#' @export
sqrtC <- function(x) {
    .Call('_MCL_sqrtC', PACKAGE = 'MCL', x)
}

